<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Instantaneous and Average Rate of Change Graph</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
<style>
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; font-family: Arial, sans-serif; color: #222;
    display: flex; flex-direction: column; align-items: center; min-height: 100vh;
    background-color: #e63946; /* solid light red - color of passion */
  }
  header {
    margin: 20px 0 10px;
    font-weight: bold; font-size: 1.4rem;
    color: white;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
  }
  #input-area {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 900px;
    background: rgba(255 255 255 / 0.95);
    border-radius: 8px;
    padding: 12px 16px;
    box-shadow: 0 2px 8px rgb(0 0 0 / 0.15);
  }
  .input-group {
    display: flex; flex-direction: column; min-width: 150px;
  }
  label {
    font-weight: 600;
    margin-bottom: 0.3rem;
  }
  input[type=text], input[type=number], select {
    padding: 0.3rem 0.5rem;
    font-size: 1rem;
    border: 1px solid #bbb;
    border-radius: 4px;
  }
  button {
    background-color: #1b262c;
    border: none;
    color: white;
    font-weight: 600;
    padding: 0.5rem 1rem;
    font-size: 1rem;
    border-radius: 4px;
    cursor: pointer;
    height: fit-content;
    align-self: center;
    margin-top: auto;
    box-shadow: 0 2px 5px rgba(27, 38, 44, 0.7);
    transition: background-color 0.25s ease;
  }
  button:hover {
    background-color: #0f1a20;
  }
  main {
    display: flex;
    gap: 1rem;
    width: 95vw;
    max-width: 1200px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-start;
  }
  #summary-container {
    max-width: 250px;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    font-size: 1rem;
    min-width: 220px;
  }
  .summary-box {
    background-color: white;
    border-radius: 8px;
    padding: 1rem;
    box-shadow: 0 0 8px rgb(0 0 0 / 0.1);
  }
  .summary-box h3 {
    margin-top: 0;
    font-weight: 700;
    font-size: 1.2rem;
    border-bottom: 1px solid #ddd;
    padding-bottom: 0.3rem;
    margin-bottom: 0.6rem;
    text-align: center;
  }
  #plot {
    flex: 1 1 600px;
    min-width: 600px;
    max-width: 720px;
    height: 480px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 0 12px rgb(0 0 0 / 0.1);
  }
  /* Below the main flex layout, a full-width container for derivative rules with scroll */
  #rules-container {
    max-width: 1000px;
    width: 95vw;
    background: white;
    border-radius: 8px;
    box-shadow: 0 0 12px rgb(0 0 0 / 0.15);
    margin: 2rem auto 3rem;
    padding: 20px 25px;
    color: #222;
    line-height: 1.5;
  }
  #rules-container h2 {
    margin-top: 0;
    color: #1b262c;
    font-weight: 700;
    margin-bottom: 16px;
    text-align: center;
  }
  .formula-box {
    border: 2px solid #1b262c;
    border-radius: 6px;
    padding: 15px 20px;
    margin-bottom: 18px;
    background: #f1f6f9;
  }
  .formula-box h3 {
    margin-top: 0;
    margin-bottom: 8px;
    color: #141b1f;
  }
  .formula-box pre {
    font-family: 'Courier New', Courier, monospace;
    font-size: 1.1rem;
    margin: 0;
    background: #dbe9f4;
    border-radius: 4px;
    padding: 10px 12px;
    overflow-x: auto;
  }
  @media (max-width: 950px) {
    main {
      flex-direction: column;
      align-items: center;
    }
    #plot {
      min-width: 90vw;
      max-width: 90vw;
      height: 400px;
    }
    #summary-container {
      max-width: 90vw;
      min-width: auto;
      flex-direction: row;
      justify-content: center;
    }
    .summary-box {
      flex: 1;
      margin: 0 0.5rem;
    }
    #input-area {
      max-width: 90vw;
    }
    #rules-container {
      width: 90vw;
      padding: 16px 18px;
    }
  }
</style>
</head>
<body>

<header>Instantaneous and Average Rate of Change Graph</header>

<div id="input-area" aria-label="Input controls">
  <div class="input-group">
    <label for="function-input">Function f(x)</label>
    <input type="text" id="function-input" placeholder="e.g. x^3 + 2*x - 5" aria-describedby="function-help" autocomplete="off" />
    <small id="function-help" style="color:#666;">Use variable: x</small>
  </div>

  <div class="input-group">
    <label for="point-input">Point x</label>
    <input type="number" id="point-input" step="any" placeholder="e.g. 1.5" />
  </div>

  <div class="input-group">
    <label for="interval-start">Interval Start</label>
    <input type="number" id="interval-start" step="any" placeholder="e.g. 1" />
  </div>

  <div class="input-group">
    <label for="interval-end">Interval End</label>
    <input type="number" id="interval-end" step="any" placeholder="e.g. 2" />
  </div>

  <div class="input-group">
    <label for="xscale">X-axis Scale</label>
    <select id="xscale" aria-label="Select scale for x-axis">
      <option value="linear" selected>Linear</option>
      <option value="log">Logarithmic</option>
    </select>
  </div>

  <div class="input-group">
    <label for="yscale">Y-axis Scale</label>
    <select id="yscale" aria-label="Select scale for y-axis">
      <option value="linear" selected>Linear</option>
      <option value="log">Logarithmic</option>
    </select>
  </div>

  <button id="plot-button" aria-label="Plot the function and rates of change">Plot</button>
</div>

<main>
  <section id="summary-container" aria-label="Derivative summaries">
    <article class="summary-box" id="instantaneous-summary" tabindex="0" aria-live="polite" aria-atomic="true">
      <h3>Instantaneous Rate of Change</h3>
      <p>Enter values and click Plot.</p>
    </article>
    <article class="summary-box" id="average-summary" tabindex="0" aria-live="polite" aria-atomic="true">
      <h3>Average Rate of Change</h3>
      <p>Enter interval and click Plot.</p>
    </article>
  </section>

  <div id="plot" role="img" aria-label="Graph of the function and tangent and secant lines"></div>
</main>

<div id="rules-container" tabindex="0" aria-label="Derivative rules and formulas">
  <h2>How to Find Derivatives: Key Rules & Formulas</h2>

  <div class="formula-box">
    <h3>Chain Rule</h3>
    <pre> If \( f(x) = h(g(x)) \), then
\( f'(x) = h'(g(x)) \times g'(x) \)</pre>
  </div>
  
  <div class="formula-box">
    <h3>Product Rule</h3>
    <pre> If \( f(x) = u(x) \times v(x) \), then
\( f'(x) = u'(x) \times v(x) + u(x) \times v'(x) \)</pre>
  </div>

  <div class="formula-box">
    <h3>Quotient Rule</h3>
    <pre> If \( f(x) = \frac{u(x)}{v(x)} \), then
\( f'(x) = \frac{u'(x) \times v(x) - u(x) \times v'(x)}{[v(x)]^2} \)</pre>
  </div>

  <div class="formula-box">
    <h3>Average Rate of Change Formula</h3>
    <pre> Average Rate of Change = \(\frac{f(b) - f(a)}{b - a}\)</pre>
  </div>

  <div class="formula-box">
    <h3>Tangent Line Equation (Point-Slope Form)</h3>
    <pre> \( y = y_1 + m (x - x_1) \)
<br>where:
<br> \( y_1 = f(x_1) \) (point on the function)
<br> \( m = f'(x_1) \) (derivative/slope at that point)
</pre>
  </div>
</div>

<script>
(() => {
  const plotDiv = document.getElementById('plot');
  const funcInput = document.getElementById('function-input');
  const pointInput = document.getElementById('point-input');
  const intervalStartInput = document.getElementById('interval-start');
  const intervalEndInput = document.getElementById('interval-end');
  const plotBtn = document.getElementById('plot-button');
  const instSummary = document.getElementById('instantaneous-summary');
  const avgSummary = document.getElementById('average-summary');
  const xScaleSelect = document.getElementById('xscale');
  const yScaleSelect = document.getElementById('yscale');

  // Utility: safely parse user function into mathjs expression and derivative
  function compileFunction(expr) {
    try {
      const node = math.parse(expr);
      const derivativeNode = math.derivative(node, 'x');
      const compiledFn = node.compile();
      const compiledDer = derivativeNode.compile();
      return { compiledFn, compiledDer };
    } catch (err) {
      return null;
    }
  }

  // Generate x array with N points over given domain (log scale supported)
  function linspace(start, end, N, scale='linear') {
    const arr = [];
    if (scale === 'log') {
      if (start <= 0 || end <= 0) return null; // log scale domain must be positive
      const logStart = Math.log10(start);
      const logEnd = Math.log10(end);
      const step = (logEnd - logStart) / (N - 1);
      for (let i = 0; i < N; i++) {
        arr.push(Math.pow(10, logStart + i * step));
      }
    } else {
      if (N <= 1) return [start];
      const step = (end - start) / (N - 1);
      for (let i = 0; i < N; i++) {
        arr.push(start + i * step);
      }
    }
    return arr;
  }

  // Evaluate f(x) for array xs safely, catch errors on individual points
  function evaluateFunction(compiled, xs) {
    return xs.map((x) => {
      try {
        const val = compiled.evaluate({ x });
        if (typeof val === 'number' && isFinite(val)) return val;
        return NaN;
      } catch {
        return NaN;
      }
    });
  }

  // Clamp interval inputs to avoid NaN or weird results
  function validInterval(a, b) {
    if (typeof a !== 'number' || typeof b !== 'number' || isNaN(a) || isNaN(b)) return false;
    return a !== b;
  }

  // Compose readable summaries
  function makeInstantaneousSummary(x, slope) {
    if (isNaN(slope)) return 'Could not calculate derivative at this point.';
    return `At x = ${x.toFixed(4)}, the instantaneous rate of change (derivative) of the function is approximately <strong>${slope.toFixed(5)}</strong>. This represents the slope of the tangent line, indicating how fast the function value is changing exactly at this point.`;
  }

  function makeAverageSummary(x1, x2, avgRate) {
    if (isNaN(avgRate)) return 'Could not calculate average rate of change over this interval.';
    return `Over the interval [${x1.toFixed(4)}, ${x2.toFixed(4)}], the average rate of change of the function is approximately <strong>${avgRate.toFixed(5)}</strong>. This corresponds to the slope of the secant line connecting the points on the graph at the interval’s endpoints.`;
  }

  // Find suitable x domain for plotting over a large span, by sampling function smartly
  function findFullDomain(compiledFn, domainStart, domainEnd, scale) {
    let xs;
    let ys;
    if (scale === 'log') {
      if (domainStart <= 0) domainStart = 0.01; // minimal positive value
      if (domainEnd <= 0) domainEnd = domainStart * 10;
      xs = linspace(domainStart, domainEnd, 1000, 'log');
      if (!xs) return null;
      ys = evaluateFunction(compiledFn, xs);
    } else {
      xs = linspace(domainStart, domainEnd, 1000, 'linear');
      ys = evaluateFunction(compiledFn, xs);
    }
    return { xs, ys };
  }

  // Main plot function
  function plotFunction() {
    const funcExpr = funcInput.value.trim();
    if (!funcExpr) {
      alert('Please enter a function of x.');
      return;
    }
    const xPoint = parseFloat(pointInput.value);
    if (isNaN(xPoint)) {
      alert('Please enter a valid number for the point x.');
      return;
    }

    let intervalStart = parseFloat(intervalStartInput.value);
    let intervalEnd = parseFloat(intervalEndInput.value);
    const hasValidInterval = validInterval(intervalStart, intervalEnd);

    const xScale = xScaleSelect.value;
    const yScale = yScaleSelect.value;

    // Compile the user function and its derivative
    const compiled = compileFunction(funcExpr);
    if (!compiled) {
      alert('Invalid function expression. Please check your syntax and use variable "x".');
      return;
    }
    const { compiledFn, compiledDer } = compiled;

    // Determine plotting domain
    // Because user function can be over an infinite domain,
    // we pick a large default domain or user interval extended by factors,
    // Also ensure domain is valid for log scale
    let domainStart, domainEnd;
    if (hasValidInterval) {
      domainStart = Math.min(intervalStart, intervalEnd);
      domainEnd = Math.max(intervalStart, intervalEnd);
    } else {
      domainStart = xPoint - 10;
      domainEnd = xPoint + 10;
    }

    // If log scale on x, domain must be positive and start < end
    if (xScale === 'log') {
      if (domainStart <= 0) {
        domainStart = 0.01;
      }
      if (domainEnd <= domainStart) {
        domainEnd = domainStart * 10;
      }
    }

    // Sample full function in domain
    const fullSample = findFullDomain(compiledFn, domainStart, domainEnd, xScale);
    if (!fullSample) {
      alert('Domain not valid for logarithmic scale.');
      return;
    }
    const { xs, ys } = fullSample;

    // Calculate y at xPoint and derivative there
    let yPoint, slopeAtPoint;
    try {
      yPoint = compiledFn.evaluate({ x: xPoint });
      slopeAtPoint = compiledDer.evaluate({ x: xPoint });
      if (!isFinite(yPoint) || !isFinite(slopeAtPoint)) throw new Error();
    } catch {
      yPoint = NaN;
      slopeAtPoint = NaN;
    }

    // Prepare tangent line data at xPoint
    const domainSpan = domainEnd - domainStart;
    const tanSpan = domainSpan * 0.15;
    let tanXStart = xPoint - tanSpan / 2;
    let tanXEnd = xPoint + tanSpan / 2;

    if (xScale === 'log') {
      if (tanXStart <= 0) tanXStart = 0.01;
      if (tanXEnd <= tanXStart) tanXEnd = tanXStart * 1.1;
    }

    const tanX = linspace(tanXStart, tanXEnd, 100, xScale);
    const tanY = tanX.map(x => slopeAtPoint * (x - xPoint) + yPoint);

    // Average rate of change and secant line plot if interval valid
    let avgRate = NaN;
    let secX = [], secY = [];
    if (hasValidInterval) {
      let fa, fb;
      try {
        fa = compiledFn.evaluate({ x: intervalStart });
        fb = compiledFn.evaluate({ x: intervalEnd });
        if (!isFinite(fa) || !isFinite(fb)) throw new Error();
      } catch {
        fa = NaN;
        fb = NaN;
      }
      if (isNaN(fa) || isNaN(fb)) {
        avgRate = NaN;
      } else {
        avgRate = (fb - fa) / (intervalEnd - intervalStart);
        secX = linspace(intervalStart, intervalEnd, 100, xScale);
        secY = secX.map(x => avgRate * (x - intervalStart) + fa);
      }
    }

    // Update summaries
    instSummary.innerHTML = `<h3>Instantaneous Rate of Change</h3><p>${makeInstantaneousSummary(xPoint, slopeAtPoint)}</p>`;
    if (hasValidInterval)
      avgSummary.innerHTML = `<h3>Average Rate of Change</h3><p>${makeAverageSummary(intervalStart, intervalEnd, avgRate)}</p>`;
    else
      avgSummary.innerHTML = `<h3>Average Rate of Change</h3><p>Enter a valid interval and click Plot to see average rate of change.</p>`;

    // Plot traces
    const traces = [
      {
        x: xs, y: ys,
        mode: 'lines',
        name: 'f(x)',
        line: { color: '#1f77b4' },
        hoverinfo: 'x+y',
        hoverlabel: { namelength: 0 },
        connectgaps: false
      },
      {
        x: tanX, y: tanY,
        mode: 'lines',
        name: `Tangent at x=${xPoint}`,
        line: { color: '#d62728', width: 3, dash: 'dashdot' },
        hoverinfo: 'x+y',
        hoverlabel: { namelength: 0 }
      },
      {
        x: [xPoint], y: [yPoint],
        mode: 'markers',
        name: 'Tangent Point',
        marker: { color: '#d62728', size: 8 },
        hoverinfo: 'x+y'
      }
    ];

    if (hasValidInterval && !isNaN(avgRate)) {
      traces.push(
        {
          x: secX, y: secY,
          mode: 'lines',
          name: `Secant on [${intervalStart},${intervalEnd}]`,
          line: { color: '#2ca02c', width: 3, dash: 'dot' },
          hoverinfo: 'x+y',
          hoverlabel: { namelength: 0 }
        },
        {
          x: [intervalStart, intervalEnd],
          y: [compiledFn.evaluate({ x: intervalStart }), compiledFn.evaluate({ x: intervalEnd })],
          mode: 'markers',
          name: 'Secant Interval Points',
          marker: { color: '#2ca02c', size: 8 },
          hoverinfo: 'x+y'
        }
      );
    }

    const layout = {
      title: {
        text: `Graph of f(x) and Rate of Change Lines`,
        font: { size: 18 },
      },
      showlegend: true,
      legend: { orientation: 'h', y: -0.2 },
      margin: { t: 50, b: 40, l: 60, r: 40 },
      xaxis: {
        title: 'x',
        zeroline: true,
        zerolinewidth: 1,
        zerolinecolor: '#bbb',
        showspikes: true,
        spikecolor: '#bbb',
        spikemode: 'across',
        spikesnap: 'cursor',
        showline: true,
        linewidth: 1,
        mirror: true,
        type: xScale,
        autorange: true,
      },
      yaxis: {
        title: 'f(x)',
        zeroline: true,
        zerolinewidth: 1,
        zerolinecolor: '#bbb',
        showspikes: true,
        spikecolor: '#bbb',
        spikemode: 'across',
        spikesnap: 'cursor',
        showline: true,
        linewidth: 1,
        mirror: true,
        type: yScale,
        autorange: true,
      },
      hovermode: 'x unified',
      height: 480,
      autosize: true,
      annotations: []
    };

    if (!isNaN(slopeAtPoint) && isFinite(yPoint)) {
      layout.annotations.push({
        x: xPoint,
        y: yPoint,
        xshift: 10,
        yshift: -10,
        text: `Tangent (slope ≈ ${slopeAtPoint.toFixed(3)})`,
        font: { color: '#d62728', size: 14, weight: 'bold' },
        showarrow: true,
        arrowhead: 2,
        arrowsize: 1,
        arrowcolor: '#d62728',
        ax: 40,
        ay: -40,
        bgcolor: '#ffe8e8',
        bordercolor: '#d62728',
        borderwidth: 1,
        borderpad: 4,
        opacity: 0.85
      });
    }
    if (hasValidInterval && !isNaN(avgRate)) {
      const midX = (intervalStart + intervalEnd) / 2;
      const midY = avgRate * (midX - intervalStart) + compiledFn.evaluate({ x: intervalStart });
      layout.annotations.push({
        x: midX,
        y: midY,
        xshift: -15,
        yshift: 20,
        text: `Secant (avg slope ≈ ${avgRate.toFixed(3)})`,
        font: { color: '#2ca02c', size: 14, weight: 'bold' },
        showarrow: true,
        arrowhead: 2,
        arrowsize: 1,
        arrowcolor: '#2ca02c',
        ax: -50,
        ay: 40,
        bgcolor: '#e8ffe8',
        bordercolor: '#2ca02c',
        borderwidth: 1,
        borderpad: 4,
        opacity: 0.85
      });
    }

    Plotly.newPlot(plotDiv, traces, layout, { responsive: true, displayModeBar: true });
  }

  plotBtn.addEventListener('click', () => {
    try {
      plotFunction();
    } catch (ex) {
      alert('Error plotting: ' + ex.message);
    }
  });

  // Accessibility: Enter key on input fields triggers plot
  [funcInput, pointInput, intervalStartInput, intervalEndInput, xScaleSelect, yScaleSelect].forEach(input => {
    input.addEventListener('keypress', e => {
      if (e.key === 'Enter') {
        plotBtn.click();
      }
    });
  });

  // Initialize with example values
  funcInput.value = 'x^3 - 3*x + 1';
  pointInput.value = '1';
  intervalStartInput.value = '0';
  intervalEndInput.value = '2';
  plotFunction(); 
})();
</script>

</body>
</html>
